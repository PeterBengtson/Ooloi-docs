# Ooloi Shared

The shared project has a unique **dual nature** serving both as a common code library and as the integration testing/combined application platform. This dual architecture enables both code reuse and sophisticated deployment scenarios.

## Table of Contents

<img src="../img/shared-ooloi.png" alt="Ooloi Shared Architecture" align="right" width="500">

1. [Core Architecture](#core-architecture)
2. [System Architecture](#system-architecture)
3. [Architecture Roles](#architecture-roles)
4. [Directory Structure](#directory-structure)
5. [Prerequisites](#prerequisites)
6. [gRPC Infrastructure](#grpc-infrastructure)
7. [Installation](#installation)
8. [Building the Combined Application](#building-the-combined-application)
9. [Build Process Details](#build-process-details)
10. [Version Handling](#version-handling)
11. [Development](#development)
12. [Configuration and Deployment](#configuration-and-deployment)
13. [Development Commands](#development-commands)
14. [Notes](#notes)
15. [Related Documentation](#related-documentation)

## Core Architecture

The shared project is **the complete Ooloi data model and API**:

### **Primary Role: Complete Data Model**
Contains the entire Ooloi data model, business logic, and API - this IS Ooloi's core functionality.

### **Secondary Role: Network Transport & Combined Applications**
Provides gRPC infrastructure for network access and packages combined applications for deployment.

### **Project Relationship**
- **Shared**: The complete Ooloi system (data models, business logic, API)
- **Backend**: gRPC wrapper around shared (network transport layer)
- **Frontend**: Consumer of shared data model (local + remote via gRPC)

### **CRITICAL: Unified Data Representation**
**There are NO separate frontend/backend data representations.**
- Same `Pitch` record used by frontend and backend
- Same `Piece` structure, same `Musician` model, same everything
- Frontend creates identical data structures to backend
- Perfect round-trip fidelity: frontend ↔ gRPC ↔ backend use identical objects

## System Architecture

The shared project enables multiple deployment architectures through its dual nature:

### Unified Data Model Architecture
```
         ┌─────────────────────────┐
         │     SHARED PROJECT      │
         │  (Complete Ooloi Core)  │
         │                         │
         │ • All Data Models       │
         │ • All Business Logic    │
         │ • Complete API          │
         │ • Traits & Interfaces   │
         │ • Operations & Utils    │
         └─────────────┬───────────┘
                       │
        ┌──────────────┼──────────────┐
        ▼              ▼              ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  Frontend   │ │   Backend   │ │  Combined   │
│  Consumer   │ │gRPC Wrapper │ │Application  │
│             │ │             │ │             │
│• UI Layer   │ │• Network    │ │• Both       │
│• Local Use  │ │  Transport  │ │  Together   │
│• gRPC Client│ │• Delegation │ │• Single JVM │
└─────────────┘ └─────────────┘ └─────────────┘
```

### Unified Data Model Usage
```
SHARED (Complete Ooloi System)
├── Frontend Local Usage
│   (create-pitch "C4" "1/4")           ← SAME Pitch record as backend
│   (pitch? some-pitch)                ← SAME predicates as backend
│
├── Frontend Remote Usage (via gRPC)
│   Frontend ──gRPC──→ Backend ──delegates──→ SAME shared functions
│   (grpc-call :create-pitch {...})     ← Returns SAME Pitch record
│
└── Backend Usage
    (create-pitch "C4" "1/4")           ← IDENTICAL to frontend
    (pitch? some-pitch)                ← IDENTICAL to frontend

KEY: Same data structures, same functions, same everything!
```

## Architecture Roles

See [ADR-0023: Shared Model Contracts](../ADRs/0023-Shared-Model-Contracts.md) for complete shared model architecture, unified system design, and multi-project integration details.

## Directory structure

```
shared/
├── docs/                             ; HTML documentation generated by Codox
├── resources/                        ; Application resources
│   └── icons/                        ; Platform-specific icons (icns, ico, png)
├── src/main/                         ; Source code
│   ├── proto/                        ; Unified gRPC Schema
│   │   └── ooloi_service.proto       ; Complete unified gRPC schema (OoloiValue + ExecuteMethod)
│   └── clojure/ooloi/shared/         ; **Complete Ooloi System**
│       ├── build.clj                 ; Build utilities and packaging
│       ├── core.clj                  ; Combined application entry point
│       ├── hierarchy.clj             ; Shared type hierarchy and dispatch values
│       ├── interfaces.clj            ; Shared multimethod interface contracts
│       ├── predicates.clj            ; Shared predicate functions (musical?, visual?, etc.)
│       ├── proto_conversion.clj      ; Clojure ↔ Protocol Buffer conversion utilities
│       ├── models/                   ; **Complete Data Model**
│       │   ├── core.clj              ; Model core and macro system
│       │   ├── changes.clj           ; ChangeSet data structure for time sigs, key sigs, tempos
│       │   ├── musical/              ; Musical data models
│       │   │   ├── piece.clj         ; Piece - root musical container
│       │   │   ├── musician.clj      ; Musician - performer representation
│       │   │   ├── instrument.clj    ; Instrument - musical instrument definition
│       │   │   ├── staff.clj         ; Staff - staff representation
│       │   │   ├── voice.clj         ; Voice - voice within staff
│       │   │   ├── measure.clj       ; Measure - musical measure
│       │   │   ├── pitch.clj         ; Pitch - musical pitch
│       │   │   ├── chord.clj         ; Chord - multiple simultaneous pitches
│       │   │   ├── rest.clj          ; Rest - musical rest
│       │   │   ├── tuplet.clj        ; Tuplet - rhythmic grouping
│       │   │   ├── tremolando.clj    ; Tremolando - rapid repetition
│       │   │   └── attachments/      ; Musical attachments
│       │   │       ├── articulation.clj ; Articulation markings
│       │   │       ├── dynamic.clj   ; Dynamic markings (forte, piano, etc.)
│       │   │       ├── glissando.clj ; Glissando markings
│       │   │       ├── hairpin.clj   ; Hairpin crescendo/diminuendo
│       │   │       ├── ottava.clj    ; Octave displacement markings
│       │   │       ├── slur.clj      ; Slur markings
│       │   │       └── tie.clj       ; Tie markings
│       │   └── visual/               ; Visual layout models
│       │       ├── layout.clj        ; Overall layout configuration
│       │       ├── page_view.clj     ; Page layout view
│       │       ├── system_view.clj   ; System layout view
│       │       ├── staff_view.clj    ; Staff layout view
│       │       └── measure_view.clj  ; Measure layout view
│       ├── ops/                      ; **Complete Operations**
│       │   ├── access.clj            ; Vector/attribute operations
│       │   ├── attachment_resolver.clj ; Attachment resolution operations
│       │   ├── changes.clj           ; Change-based operations
│       │   ├── persistence.clj       ; Persistence operations
│       │   ├── piece_ref.clj         ; Piece reference operations
│       │   ├── pitches.clj           ; Pitch normalization and conversion utilities
│       │   ├── rhythm.clj            ; Duration and rhythm processing utilities
│       │   ├── text.clj              ; Text processing (pluralization, singularization)
│       │   ├── timewalk.clj          ; Musical structure traversal and analysis operations
│       │   └── vpd.clj               ; VPD operations and addressing utilities
│       ├── specs/                    ; Test data generation
│       │   └── generators.clj        ; Test data generators for all models
│       └── traits/                   ; **All Behavioral Traits**
│           ├── attachment.clj        ; Attachment behavior trait
│           ├── has_items.clj         ; Collection behavior trait
│           ├── rhythmic_item.clj     ; Rhythmic behavior trait
│           ├── takes_attachment.clj  ; Attachment acceptance trait
│           └── transposable.clj      ; Transposition behavior trait
├── test/                             ; Comprehensive test suite (~15,048 tests)
├── util/                             ; Utility scripts
└── project.clj                       ; Project configuration and dependencies
```

## Prerequisites

### System Requirements

- **Java Development Kit (JDK) 22 or later** - Required for running the combined application
- **Leiningen 2.9.0 or later** - Clojure build tool for dependency management and building
- **Protocol Buffers Compiler (protoc) 3.25.3 or later** - For gRPC code generation (automatically downloaded by lein-protoc)
- **Git** - For version control and accessing the repository
- **Minimum 8GB RAM** - Recommended for combined application with both backend and frontend
- **Network access** - For downloading dependencies and gRPC communication

### Platform Setup

**Requirements**: Java 22+ and Leiningen 2.9.0+

#### macOS
```bash
brew install openjdk@22 leiningen protobuf
export JAVA_HOME="/usr/local/opt/openjdk@22"
```

#### Linux (Ubuntu/Debian)
```bash
sudo apt install openjdk-22-jdk openjfx protobuf-compiler
curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein > ~/bin/lein
chmod +x ~/bin/lein
export JAVA_HOME="/usr/lib/jvm/java-22-openjdk-amd64"
```

#### Windows
- Install OpenJDK 22 from [Adoptium](https://adoptium.net/)
- Download `lein.bat` from [Leiningen](https://leiningen.org/) and run `lein self-install`
- Set `JAVA_HOME` environment variable

#### Dependencies
Protocol Buffers, JavaFX, and Skija are included in project dependencies.

#### Verification
```bash
java -version && lein version
```

## gRPC Infrastructure

The shared project contains Protocol Buffer definitions for frontend-backend communication:

### Protocol Buffer Schema

- **`ooloi_service.proto`**: gRPC service definitions

### Conversion Utilities

- **`proto_conversion.clj`**: Clojure ↔ Protocol Buffer conversion

### Build Integration

- `lein compile` generates unified gRPC infrastructure in `target/generated-sources/protobuf/`
- Universal `OoloiService` client/server classes used by all projects
- Supports distributed (client-server), combined (single-JVM), and in-process deployment modes

## Installation

  ```bash
  cd shared
  lein deps
  ```

## Building the Combined Application

1. Navigate to the shared directory:
   ```bash
   cd shared
   ```

2. Run tests:
   ```bash
   lein midje
   ```
   
   The test suite includes comprehensive coverage of:
   - Protocol Buffer conversion utilities
   - Round-trip conversion symmetry for all data types

3. Build the application:
   ```bash
   lein build
   ```

   This command will perform the following steps:
   - Clean the project
   - Create an uberjar
   - Run jlink to create a custom runtime
   - Run the build function to package the application

   You will see colored output indicating the progress of each step.

4. The packaged shared application will be in the `shared/target` directory.

## Build Process Details

The build process uses the following tools and steps:

1. **Cleaning**: Removes previous build artifacts.
2. **Uberjar Creation**: Compiles the code and creates a standalone jar file.
3. **Jlink**: Creates a custom Java runtime with only the necessary modules.
4. **Jpackage**: Packages the application for distribution, creating platform-specific installers or application images.

The build process handles both SNAPSHOT (development) versions and release versions:

- For SNAPSHOT versions, it creates an app image.
- For release versions, it creates platform-specific installers (DMG for macOS, DEB for Linux, MSI for Windows).

## Version Handling

The build process automatically adjusts version numbers for compatibility with different platforms:

- SNAPSHOT suffixes are removed for the final package version.
- If the version starts with "0", it's changed to "1.0.0" for macOS compatibility.
- The original version (including SNAPSHOT if applicable) is included in the application name.

## Development

### Quick Start: What You Need for 90% of Your Code

**Whether you're developing frontend or backend, 90% of your code only needs this:**

```clojure
(ns my-namespace
  (:require [ooloi.shared.models.core :refer :all]))
```

This gives you access to:
- **All constructors**: `create-pitch`, `create-chord`, `create-measure`, etc.
- **All predicates**: `pitch?`, `chord?`, `measure?` (raw items), plus `pitch??`, `chord??`, `measure??` (timewalk tuples), etc.
- **All multimethods**: `get-duration`, `add-item`, `set-name`, etc.
- **Complete Ooloi system**: Everything you need for frontend AND backend development

**Why this works**: The shared `core` namespace IS the complete Ooloi system - frontend and backend both consume it identically.

**Architecture Reality**: Frontend and backend use SAME functions, SAME data structures, SAME everything from shared/. No conversion, no separate representations.

### Running the Combined Application

To run the application for development:

```bash
lein run
```

This will start the Ooloi combined application.

## Configuration and Deployment

The shared project supports comprehensive configuration for orchestrating both frontend and backend components:

### Command-Line Arguments

The shared project supports orchestration modes with comprehensive configuration:

```bash
# Basic combined application
lein run

# Integration testing mode
lein run -- --mode integration-test --frontend-port 10800 --backend-port 10700

# Single-process combined deployment
lein run -- --mode combined --ui-mode graphical --transport in-process

# Distributed coordination mode  
lein run -- --mode distributed --frontend-host remote-frontend --backend-host remote-backend

# Development orchestration
lein run -- --mode dev-orchestrator --auto-restart true --log-level debug
```

#### Available CLI Arguments

| **Argument** | **Values** | **Default** | **Description** |
|--------------|------------|-------------|-----------------|
| `--mode MODE` | integration-test, combined, distributed, dev-orchestrator | combined | Deployment orchestration mode |
| `--frontend-host HOST` | hostname/IP | localhost | Frontend component hostname |
| `--frontend-port PORT` | 1-65535 | 10800 | Frontend component port |
| `--backend-host HOST` | hostname/IP | localhost | Backend component hostname |
| `--backend-port PORT` | 1-65535 | 10700 | Backend component port |
| `--transport MODE` | network, in-process, auto | auto | Inter-component transport |
| `--ui-mode MODE` | graphical, headless, auto | auto | UI display mode for combined deployment |
| `--integration-timeout MS` | milliseconds | 30000 | Integration test timeout |
| `--auto-restart BOOL` | true, false | false | Auto-restart components on failure |
| `--log-level LEVEL` | debug, info, warn, error | info | Application logging level |
| `--health-port PORT` | 1-65535 | 10801 | Combined application health endpoint |
| `--tls BOOL` | true, false | false | Enable TLS for all communications |

### Environment Variables

All CLI arguments have corresponding environment variable alternatives:

| **Environment Variable** | **CLI Equivalent** | **Description** |
|-------------------------|-------------------|-----------------|
| `OOLOI_SHARED_MODE` | --mode | Deployment orchestration mode |
| `OOLOI_SHARED_FRONTEND_HOST` | --frontend-host | Frontend component hostname |
| `OOLOI_SHARED_FRONTEND_PORT` | --frontend-port | Frontend component port |
| `OOLOI_SHARED_BACKEND_HOST` | --backend-host | Backend component hostname |
| `OOLOI_SHARED_BACKEND_PORT` | --backend-port | Backend component port |
| `OOLOI_SHARED_TRANSPORT` | --transport | Inter-component transport mode |
| `OOLOI_SHARED_UI_MODE` | --ui-mode | UI display mode |
| `OOLOI_SHARED_INTEGRATION_TIMEOUT` | --integration-timeout | Integration test timeout |
| `OOLOI_SHARED_AUTO_RESTART` | --auto-restart | Auto-restart on component failure |
| `OOLOI_SHARED_LOG_LEVEL` | --log-level | Application logging level |
| `OOLOI_SHARED_HEALTH_PORT` | --health-port | Health monitoring port |
| `OOLOI_SHARED_TLS` | --tls | Enable TLS communications |

### Deployment Modes

#### integration-test
**Components:** Integration Orchestrator + Test Frontend + Test Backend  
**Use Case:** Deep integration testing between frontend and backend components
```bash
lein run -- --mode integration-test
```
- Starts both frontend and backend in test mode
- Runs comprehensive integration test suite
- Validates gRPC communication paths
- Tests all transport modes and failure scenarios

#### combined
**Components:** All components in single JVM  
**Use Case:** Single-process deployment with maximum performance
```bash
lein run -- --mode combined --transport in-process
```
- Ultra-high-performance in-process communication
- Single JVM with all components
- Minimal resource usage
- Ideal for standalone deployments

#### distributed
**Components:** Coordination of remote frontend and backend  
**Use Case:** Multi-machine deployment coordination
```bash
lein run -- --mode distributed --frontend-host client-machine --backend-host server-machine
```
- Coordinates remote component deployment
- Manages inter-machine communication
- Handles distributed failure scenarios
- Load balancing and health coordination

#### dev-orchestrator
**Components:** Development tooling and component management  
**Use Case:** Development environment management
```bash
lein run -- --mode dev-orchestrator --auto-restart true
```
- Auto-restart components on code changes
- Development-friendly logging and debugging
- Hot reloading coordination
- Developer productivity optimizations

### Component Architecture

The shared system includes these Integrant components:

#### Integration Orchestrator Component
- **Component coordination** between frontend and backend
- **Health monitoring** across all components
- **Failure detection** and automatic recovery
- **Transport optimization** based on deployment mode

#### Configuration Manager Component  
- **Environment detection** and mode selection
- **Component configuration** propagation
- **Runtime reconfiguration** support
- **Deployment validation** and compatibility checking

#### Test Coordination Component
- **Integration test execution** across frontend-backend boundary
- **Test data management** using shared generators
- **Performance benchmarking** of different transport modes
- **Regression test automation** for gRPC communication

### Integration Testing Architecture

The shared project serves as the **integration testing hub**:

```bash
# Comprehensive integration testing
export OOLOI_SHARED_MODE=integration-test
export OOLOI_SHARED_INTEGRATION_TIMEOUT=60000
lein run

# Performance benchmarking
lein run -- --mode integration-test --transport in-process --benchmark true

# Multi-user collaboration testing
lein run -- --mode integration-test --multi-client true --client-count 5
```

### Monitoring and Health (Future)

When the shared project gets its own system components, it will provide comprehensive monitoring for the combined application:

**Multi-Component Health Status:**
- Health aggregation across frontend and backend components
- Inter-component communication monitoring
- Distributed system health coordination
- Cross-boundary error tracking and recovery

**Integration Test Monitoring:**
- Real-time integration test execution status
- Performance metrics across transport modes
- Regression detection and alerting
- Multi-user collaboration test results

**Application Lifecycle Coordination:**
- **Startup**: Orchestrates component initialization in correct dependency order
- **Runtime**: Monitors health across component boundaries, handles partial failures
- **Shutdown**: Coordinates graceful shutdown of all managed components

**Production Readiness (Future):**
- **Distributed health endpoints**: Coordination across multiple machines
- **Integration monitoring**: Real-time gRPC communication health
- **Performance telemetry**: Transport optimization metrics and recommendations
- **Component isolation**: Failure isolation preventing cascade failures

## Development Commands

### Running Tests

The shared project uses Midje for comprehensive testing:

```bash
# Run all tests
lein midje

# Run specific test namespace
lein midje ooloi.shared.proto-conversion-test

# Run tests with coverage report
lein coverage
```

### Architecture Insights

**Unified Data Model Access**: Frontend and backend use IDENTICAL shared system:

```clojure
;; Frontend code (identical to backend)
[ooloi.shared.models.musical.pitch :refer [create-pitch]]     ; Same Pitch record
[ooloi.shared.interfaces :as i]                              ; Same API functions
[ooloi.shared.predicates :as p]                              ; Same predicates

;; Backend code (identical to frontend)  
[ooloi.shared.models.musical.pitch :refer [create-pitch]]     ; SAME Pitch record
[ooloi.shared.interfaces :as i]                              ; SAME API functions
[ooloi.shared.predicates :as p]                              ; SAME predicates

;; Result: (= frontend-pitch backend-pitch) => true
```

**Design Principle**: ONE data model, ONE API, used identically by frontend and backend. No conversion, no mapping, no separate representations - just the same shared objects everywhere.

**Complete System Access**: All Ooloi functionality in `shared/src` available to both frontend (local use + gRPC client) and backend (gRPC wrapper).

### Dual Nature Development Implications

**Code Library Development:**
```bash
# Developing shared code used by both projects
cd shared/
# Edit shared models, traits, interfaces
lein midje  # Test shared code in isolation
cd ../backend && lein midje  # Test backend integration
cd ../frontend && lein midje  # Test frontend integration
```

**Integration Platform Development:**  
```bash
# Developing combined application features
cd shared/
lein run  # Test combined application
# Edit integration orchestration components
lein midje  # Test integration scenarios
```

**Deployment Flexibility Benefits:**
- **Single Repository**: All three projects in one repo with shared development workflow
- **Selective Dependencies**: Frontend/backend can import only needed shared modules
- **Integration Testing**: Comprehensive testing across component boundaries
- **Combined Packaging**: Single JAR for deployment scenarios requiring both components
- **Code Reuse**: Maximum reuse while maintaining architectural boundaries

### Development Workflow Coordination

**gRPC Schema Changes** (extremely rare):
1. Edit `shared/src/main/proto/ooloi_service.proto` only if adding fundamental Clojure data types
2. Compile: `lein clean && lein compile`  
3. Test: `lein midje`

**Shared Model Changes** (normal development):
1. Edit models/traits/interfaces in `shared/src/main/clojure/`
2. Test: `lein midje` - changes automatically work across all projects
3. No compilation cascades needed - unified system handles everything

### gRPC Infrastructure Management

The shared project contains the **unified gRPC schema** used by both backend and frontend:

```bash
# Compile application (includes automatic gRPC infrastructure)
lein compile

# View generated gRPC infrastructure
ls target/generated-sources/protobuf/
```

#### Unified gRPC Schema

The shared project provides Ooloi's **unified gRPC architecture**:

- **`src/main/proto/ooloi_service.proto`** - Complete unified schema
  - **Universal OoloiValue**: Handles all Clojure data types automatically
  - **ExecuteMethod**: Single endpoint for all API methods via dynamic resolution
  - **ExecuteBatch**: Streaming operations for atomic STM transactions

#### Zero-Maintenance Architecture

**No compilation needed for**:
- New API methods in backend
- New data models or shared records
- Plugin installations
- Shared model contract changes

**Rare recompilation** only when `ooloi_service.proto` itself changes:
```bash
# Only if the unified schema structure is modified
lein clean && lein compile
```

**Development Reality**: Simple workflow:
```bash
# Make any changes - new models, API methods, plugins, etc.
lein midje  # Test your changes - no compilation cascades needed
```

### Building and Packaging

```bash
# Full build process (clean, compile, test, package combined application)
lein build

# Create standalone JAR for combined application
lein uberjar

# Clean build artifacts
lein clean
```

### Documentation Generation

```bash
# Generate API documentation
lein codox
```
The documentation will be generated in the `docs` directory.

### Development Workflow

Recommended development sequence:

1. **Make Changes**: Edit shared models, backend API methods, frontend code, etc.
2. **Test**: `lein midje` in relevant project - unified system handles everything automatically
3. **Integration**: All changes work immediately across projects via unified gRPC architecture

**Reality**: The unified system eliminates complex development workflows - just code and test!

## Notes

- Ensure all tests pass before creating the final package.
- The packaged application is platform-specific and ready for distribution.
- JavaFX is included in the project dependencies, ensuring GUI capabilities.

Remember to run tests (`lein midje`) before packaging to ensure everything is working correctly.

## Related Documentation

### Architecture Guides
- **[Polymorphic API Guide](/guides/POLYMORPHIC_API_GUIDE.md)** - Type system foundations underlying the shared model architecture
- **[Ooloi Server Architectural Guide](/guides/OOLOI_SERVER_ARCHITECTURAL_GUIDE.md)** - Server architecture built on shared model contracts
- **[gRPC Communication and Flow Control](/guides/GRPC_COMMUNICATION_AND_FLOW_CONTROL.md)** - How shared types enable network serialization

### Technical Documentation
- **[Development Plan](/DEV_PLAN.md)** - Current development status and implementation roadmap
- **[ADR-0023: Shared Model Contracts](/ADRs/0023-Shared-Model-Contracts.md)** - Multi-project architecture decisions
- **[gRPC Streaming & Threading Guide](/guides/GRPC_STREAMING_THREADING_GUIDE.md)** - Advanced streaming implementation patterns
