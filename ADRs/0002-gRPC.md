# ADR-0002: Adoption of gRPC for Communication Between Frontend and Backend

## Status

Accepted (Updated July 2025)

## Context

Ooloi's architecture involves separate frontend and backend Clojure applications. This separation necessitates a robust, efficient, and flexible communication mechanism between these two components. We need to choose a protocol that can handle complex data structures, provide type safety, and offer high performance for real-time interactions with large musical scores.

**Updated Context (July 2025)**: Production experience and community feedback show significant limitations with native Clojure gRPC solutions:

- **Protojure limitations**: Missing enterprise features like automatic client reconnection, manual trailer handling requirements, and production scalability constraints
- **Ecosystem maturity**: Java interop provides full gRPC feature parity with better performance characteristics  
- **Industry adoption**: Companies like AppsFlyer (1000+ Clojure developers) demonstrate successful production-scale Java interop usage

## Decision

We will use **gRPC with Java interop** (grpc-java) as the primary communication protocol between Ooloi's frontend and backend applications, specifically choosing the mature Java ecosystem over native Clojure gRPC libraries.

## Rationale

### Core gRPC Benefits

1. **Performance**:
   - gRPC uses Protocol Buffers, a lightweight binary serialization format.
   - Offers significantly faster serialization and deserialisation compared to JSON.
   - Supports streaming, crucial for real-time updates of large scores.

2. **Type Safety**:
   - Strongly typed interface definitions via Protocol Buffers.
   - Reduces errors related to data type mismatches between frontend and backend.

3. **Language Agnostic**:
   - While we're using Clojure for both frontend and backend, gRPC's language-agnostic nature provides flexibility for future expansions or integrations.

4. **Bi-directional Streaming**:
   - Allows for efficient, real-time updates from backend to frontend.
   - Crucial for live collaboration features and real-time score rendering.

5. **Code Generation**:
   - Automatic client and server code generation from service definitions.
   - Reduces boilerplate and ensures consistency between client and server implementations.

6. **Compression**:
   - Built-in support for data compression, beneficial for transferring large musical scores.

7. **Multiplexing**:
   - Supports multiple simultaneous requests over a single connection.
   - Improves efficiency, especially important for complex score manipulations.

8. **Community and Ecosystem**:
   - Strong community support and a growing ecosystem.
   - Well-documented and actively maintained.

9. **Cross-platform Support**:
   - Works well across different operating systems, aligning with Ooloi's cross-platform goals.

10. **Future-proofing**:
    - Scalable architecture that can support future cloud-based deployments if needed.

### Java Interop Advantages (Updated July 2025)

1. **Production Maturity**: Full access to enterprise gRPC features including interceptors, deadlines, and advanced error handling
2. **Performance**: Better performance characteristics than native Clojure implementations  
3. **Feature Completeness**: Access to the entire gRPC Java ecosystem without waiting for Clojure-specific implementations
4. **Operational Reliability**: Proven in high-scale production environments
5. **Ecosystem Integration**: Seamless integration with existing Java tooling and monitoring solutions

### Component Integration

The Java interop approach integrates cleanly with Clojure's Component library for lifecycle management:

```clojure
(defrecord OoloiService [piece-manager]
  component/Lifecycle
  (start [this]
    (let [server (-> (ServerBuilder/forPort 5000)
                     (.addService 
                      (proxy [OoloiGrpc$OoloiImplBase] []
                        (createPiece [^CreatePieceRequest req ^StreamObserver observer]
                          ;; Delegate to pure Clojure business logic
                          (let [piece (api/create-piece piece-manager (.getName req))]
                            (-> (build-piece-response piece)
                                (->> (.onNext observer)))
                            (.onCompleted observer)))))
                     .build .start)]
      (assoc this :server server)))
  
  (stop [this]
    (when-let [server (:server this)]
      (.shutdown server))
    (dissoc this :server)))

(defn ooloi-system []
  (component/system-map
   :piece-manager (pm/new-piece-manager)
   :grpc-server (component/using
                 (grpc/new-grpc-service)
                 [:piece-manager])))
```

## Consequences

### Positive

- **High-performance communication** suitable for real-time score editing
- **Strong typing** reduces runtime errors related to data transfer
- **Efficient handling** of large data structures (complex musical scores)
- **Streamlined development process** with code generation
- **Flexibility** for future expansion to other platforms or languages
- **Production readiness** with full enterprise gRPC feature set from day one
- **Component integration** enabling clean lifecycle management and dependency injection
- **Ecosystem access** to the entire Java gRPC ecosystem
- **Performance optimisation** through mature Java implementations

### Negative

- **Learning curve** for developers not familiar with gRPC, Protocol Buffers, and Java interop
- **Slightly more complex setup** compared to REST APIs
- **Potential challenges in debugging** due to binary nature of communication
- **Interop complexity** requiring data conversion between Java objects and Clojure data structures
- **Additional dependencies** on Java gRPC libraries

### Mitigations

- Create Clojure wrapper functions for common gRPC operations
- Implement comprehensive logging at conversion boundaries  
- Develop testing patterns that work across the interop boundary
- Provide clear documentation and examples for the development team

## Implementation Approach

### 1. Dependencies and Build Configuration

Update project dependencies to use official gRPC Java libraries:

```clojure
:dependencies [[io.grpc/grpc-netty "1.60.0"]
               [io.grpc/grpc-protobuf "1.60.0"] 
               [io.grpc/grpc-stub "1.60.0"]
               [com.google.protobuf/protobuf-java "3.25.1"]
               [com.stuartsierra/component "1.1.0"]]

:plugins [[lein-protoc "0.4.1"]]

:protoc {:proto-paths ["src/main/proto"]
         :output-path "target/generated-sources/grpc"
         :java-options {:language "java"}}
```

### 2. Define Protocol Buffer Messages and Services

Create comprehensive `.proto` files for all shared data structures (e.g., musical elements, layout information) and service definitions.

### 3. Code Generation Pipeline

Set up automated code generation for both frontend and backend using `lein-protoc` plugin, ensuring generated classes are included in the project classpath.

### 4. Service Implementation with Component Integration

Implement gRPC services as Components with proper dependency injection:

```clojure
(ns ooloi.backend.grpc.service
  (:require [com.stuartsierra.component :as component]
            [ooloi.backend.api :as api])
  (:import [io.grpc Server ServerBuilder]
           [io.grpc.stub StreamObserver]
           [ooloi.backend OoloiGrpc$OoloiImplBase]
           [ooloi.backend CreatePieceRequest Piece GetPieceRequest]))
```

### 5. Architectural Separation

- **gRPC Layer**: Minimal Java interop handling serialisation and transport
- **Business Logic**: Pure Clojure functions for all musical operations  
- **Data Conversion**: Efficient bidirectional conversion utilities between Protocol Buffers and Clojure data structures
- **Component Management**: Stuart Sierra's Component for lifecycle and dependency injection

### 6. Bi-directional Streaming Implementation

Implement streaming for real-time updates using gRPC's streaming capabilities with proper resource management and error handling.

### 7. Error Handling and Retry Mechanisms

Implement robust error handling using gRPC status codes with comprehensive retry mechanisms for resilient communication.

### 8. Testing Infrastructure

Develop comprehensive testing suites covering:
- Unit tests for individual service methods
- Integration tests for full client-server interactions
- Performance tests for large score handling
- Mock services for controlled testing environments

### 9. Security Implementation

Implement TLS encryption and authentication mechanisms appropriate for production deployment.

### 10. Monitoring and Observability

Set up gRPC-specific metrics collection and distributed tracing for production monitoring.

## Alternatives Considered

1. **Protojure (Native Clojure)**: Rejected due to production limitations including missing enterprise features like automatic client reconnection, manual trailer handling requirements, and performance constraints in high-load scenarios.

2. **REST API with JSON**: Rejected due to performance concerns with large datasets, lack of native streaming support, and absence of strong typing for complex musical data structures.

3. **WebSocket**: Considered for its real-time capabilities but rejected due to lack of built-in type safety, less structured approach to API definition, and absence of sophisticated error handling mechanisms.

4. **Apache Thrift**: Similar benefits to gRPC but rejected due to gRPC's better language support, more active community, and superior streaming capabilities.

5. **Custom Binary Protocol**: Considered for maximum performance but rejected due to development overhead, lack of tooling, and reinvention of solved problems.

## Implementation Status

This decision reflects lessons learned from comprehensive gRPC ecosystem analysis conducted in 2024-2025, replacing any previous assumptions about using native Clojure gRPC libraries. The Java interop approach provides the reliability, performance characteristics, and feature completeness required for Ooloi's production deployment.

The choice prioritises production reliability and operational maturity over development convenience, whilst maintaining Ooloi's functional programming principles through careful architectural separation.

## References

- [gRPC in Clojure: 2025 Production Guide](../docs/gRPC-in-Clojure-2025-Production-Guide.md)
- [Component Library Documentation](https://github.com/stuartsierra/component)  
- [grpc-java Documentation](https://grpc.io/docs/languages/java/)
- [Protocol Buffers Documentation](https://developers.google.com/protocol-buffers)

## Notes

While this approach requires additional interop handling compared to native Clojure solutions, the trade-off strongly favours production reliability and feature completeness. The Component-based architecture ensures that gRPC concerns remain properly isolated from business logic, maintaining clean separation of transport and domain concerns.

The implementation should monitor performance and developer experience in practice. Should unexpected complexities or performance issues arise, this decision may need reevaluation, though the current evidence strongly supports the Java interop approach for production systems.

We should also monitor the evolution of gRPC and related technologies, particularly any improvements to native Clojure implementations, to ensure we continue using the most effective communication method as the project scales.
