# ADR-0002: Adoption of gRPC for Communication Between Frontend and Backend

## Table of Contents

- [Status](#status)
- [Context](#context)
- [Decision](#decision)
- [Rationale](#rationale)
  - [Core gRPC Benefits](#core-grpc-benefits)
  - [Dual Data Transmission Requirements](#dual-data-transmission-requirements)
  - [gRPC Streaming Architecture](#grpc-streaming-architecture)
  - [Java Interop Advantages](#java-interop-advantages)
  - [Integrant Integration](#integrant-integration)
- [Consequences](#consequences)
- [Implementation Approach](#implementation-approach)
- [Alternatives Considered](#alternatives-considered)
- [References](#references)
- [Notes](#notes)

## Status

Accepted

## Context

Ooloi's architecture supports **three deployment models**: backend-only, frontend-only, and combined applications. The **backend hosts a gRPC server** while the **frontend acts as a gRPC client**. In combined deployments, both client and server run in the same process, while in separate deployments they communicate over the network. We need to choose a protocol that can handle complex data structures, provide type safety, and offer high performance for real-time interactions with large musical scores.

**Additional Context**: Analysis of native Clojure gRPC solutions reveals significant limitations:

- **Protojure limitations**: Missing enterprise features like automatic client reconnection, manual trailer handling requirements, and production scalability constraints
- **Ecosystem maturity**: Java interop provides full gRPC feature parity with better performance characteristics  
- **Industry adoption**: Companies like AppsFlyer (1000+ Clojure developers) demonstrate successful production-scale Java interop usage

## Decision

We will use **gRPC with Java interop** (grpc-java) for communication between Ooloi's frontend and backend components. The **shared project serves dual purposes**: containing protocol definitions and shared utilities, plus packaging combined applications, supporting three deployment models:

1. **Backend-only** binary (server only)
2. **Frontend-only** binary (client connecting to remote server)  
3. **Combined** binary (both client and server in same process)

In all cases, the backend component hosts the gRPC server while the frontend component acts as a gRPC client.

**Architectural Principle: API-gRPC Equivalence**
The gRPC interface will provide 1:1 correspondence with Ooloi's `api.clj` namespace. Every function in `api.clj` represents an operation designed for remote access and will have a corresponding gRPC method. This ensures the gRPC interface is comprehensive, consistent, and aligned with the intended public API - no more, no less.

## Rationale

### Core gRPC Benefits

1. **Performance**:
   - gRPC uses Protocol Buffers, a lightweight binary serialization format.
   - Offers significantly faster serialization and deserialisation compared to JSON.
   - Supports streaming, crucial for real-time updates of large scores.

### Dual Data Transmission Requirements

Ooloi's gRPC communication must handle a **dual spectrum of data transmission patterns**, both requiring excellent performance:

**Substantial Musical Data:**
- **Complete symphonies**: Large orchestral scores with hundreds of measures, multiple instruments, complex arrangements
- **Full piece synchronization**: Initial loading and client synchronization of entire musical works
- **Batch operations**: Multiple musical edits, undo/redo operations, and bulk modifications
- **Import/export operations**: Loading MusicXML files, MIDI imports, and large-scale data exchanges

**Lightweight Drawing Instructions:**
- **Real-time graphics updates**: Backend-calculated drawing instructions sent to frontend for JavaFX rendering
- **Visual synchronization**: Incremental layout updates, cursor movements, selection changes
- **Interactive feedback**: Immediate visual responses to musical edits, playback cursors, UI indicators
- **Minimal rendering data**: MeasureView structures containing only glyphs and curves with coordinates - no bitmap transmission

**Performance Characteristics:**
The gRPC architecture excels at both extremes through Protocol Buffer efficiency:
- **Large data**: Compression and binary serialization handle substantial musical content efficiently
- **Lightweight data**: Minimal serialization overhead for frequent small updates
- **Mixed patterns**: Single connection handles both large synchronization and frequent small updates seamlessly
- **No conversion overhead**: String/keyword flexibility eliminates forced type conversion during transmission

This dual nature ensures gRPC performs excellently whether transmitting a complete Mahler symphony or a single cursor position update.

2. **Language Agnostic**:
   - While we're using Clojure for both frontend and backend, gRPC's language-agnostic nature provides flexibility for future expansions or integrations.

3. **Server-to-Client Event Notifications**:
   - Allows for efficient, real-time invalidation notifications from backend to frontend.
   - Supports lazy data synchronization and multi-client scenarios when needed.

### gRPC Streaming Architecture

Ooloi leverages gRPC's streaming capabilities for event notifications and data streaming:

**Streaming Patterns:**

1. **Unary RPC** (Request-Response):
   - Standard API operations: `AddArticulation`, `GetMeasure`, `SetTimeSignature`
   - Bulk operations: piece loading, save operations, import/export
   - Simple query operations: retrieving musical elements, layout information

2. **Server Streaming** (Request-Stream Response):
   - **Event notifications**: Backend pushes discrete invalidation events about piece changes to subscribed clients
   - **Progress updates**: Long-running operations (MIDI generation, complex layout calculations)
   - **Data streaming** (future): Bulk file transfers (MusicXML, MIDI, audio files)

3. **Client Streaming with STM Transaction Boundaries** (Stream Request-Response):
   - **STM-composable batch operations**: Multiple VPD operations streamed and processed within single `dosync` transaction
   - **Distributed transaction integrity**: Client streams operations → Server accumulates → STM boundary wraps all → Atomic success/failure
   - **Multi-client coordination**: When multiple clients access same piece, edits batched and applied atomically with ACID guarantees
   - **Undo/redo chains**: Streaming multiple operations creates natural STM transaction boundaries for state management
   - **Import processing**: Large MusicXML/MIDI files streamed and applied atomically in transactional chunks

4. **Bidirectional Streaming** (Stream Request-Stream Response) - **Future Capability**:
   - **Bulk data transfer**: Large file upload/download with progress feedback
   - **Interactive data processing**: Real-time analysis with streaming results
   - **Live performance mode**: Continuous interaction between score display and performance input
   - **Audio-visual synchronization**: Coordinating MIDI playback with visual score updates

**Multi-Client Scenarios:**
- **Primary use case**: Single-user desktop with local server (99.99% of scenarios)
- **Classroom playback**: Multiple students viewing same score with synchronized playback
- **Teacher-student editing**: Occasional simultaneous editing of student work
- **Architecture transparency**: Server location (local/remote) irrelevant to client implementation

**Performance Benefits:**
- **Connection efficiency**: Multiple operations over single persistent connection
- **Reduced latency**: No connection setup overhead for frequent updates
- **Resource optimization**: Shared connection state reduces memory and CPU usage
- **Flow control**: Built-in backpressure handling prevents overwhelming slow clients

**Technical Implementation:**
```protobuf
service OoloiService {
  // Unary: Standard API operations
  rpc AddArticulation(AddArticulationRequest) returns (AddArticulationResponse);

  // Server streaming: Client synchronization
  rpc SubscribeToPieceEvents(PieceSubscriptionRequest) returns (stream PieceEvent);

  // Client streaming: STM-composable batch operations with distributed transaction integrity
  rpc ExecuteBatchOperations(stream BatchOperationRequest) returns (BatchOperationResponse);

  // Bidirectional: Interactive processing
  rpc ProcessInteractive(stream ProcessInput) returns (stream ProcessOutput);
}
```

This streaming architecture provides efficient frontend-backend communication with proper separation of concerns, supporting everything from single-user desktop scenarios to specialized multi-client use cases.

4. **Code Generation**:
   - Automatic client and server code generation from service definitions.
   - Reduces boilerplate and ensures consistency between client and server implementations.

5. **Compression**:
   - Built-in support for data compression, beneficial for transferring large musical scores.

6. **Multiplexing**:
   - Supports multiple simultaneous requests over a single connection.
   - Improves efficiency, especially important for complex score manipulations.

7. **Community and Ecosystem**:
   - Strong community support and a growing ecosystem.
   - Well-documented and actively maintained.

8. **Cross-platform Support**:
   - Works well across different operating systems, aligning with Ooloi's cross-platform goals.

9. **Future-proofing**:
    - Scalable architecture that can support future cloud-based deployments if needed.

### Java Interop Advantages

1. **Production Maturity**: Full access to enterprise gRPC features including interceptors, deadlines, and advanced error handling
2. **Performance**: Better performance characteristics than native Clojure implementations  
3. **Feature Completeness**: Access to the entire gRPC Java ecosystem without waiting for Clojure-specific implementations
4. **Operational Reliability**: Proven in high-scale production environments
5. **Ecosystem Integration**: Seamless integration with existing Java tooling and monitoring solutions

### Integrant Integration

The Java interop approach integrates cleanly with Integrant for lifecycle management:

```clojure
(defmethod ig/init-key :ooloi/grpc-server [_ {:keys [piece-manager]}]
  (let [server (-> (ServerBuilder/forPort 5000)
                   (.addService 
                    (proxy [OoloiGrpc$OoloiImplBase] []
                      (createPiece [^CreatePieceRequest req ^StreamObserver observer]
                        ;; Delegate to pure Clojure business logic
                        (let [piece (api/create-piece piece-manager (.getName req))]
                          (-> (build-piece-response piece)
                              (->> (.onNext observer)))
                          (.onCompleted observer)))))
                   .build .start)]
    {:server server}))

(defmethod ig/halt-key! :ooloi/grpc-server [_ {:keys [server]}]
  (.shutdown server))

;; System configuration
{:ooloi/piece-manager {}
 :ooloi/grpc-server {:piece-manager (ig/ref :ooloi/piece-manager)}}
```

## Consequences

### Positive

- **High-performance communication** suitable for real-time score editing
- **Efficient handling** of large data structures (complex musical scores)
- **Complete API coverage** ensuring all `api.clj` functions are remotely accessible
- **Consistent interface** maintaining 1:1 correspondence between local and remote operations
- **Streamlined development process** with code generation and thin delegation layer
- **Deployment flexibility** supporting combined binaries or distributed client-server architectures
- **Flexibility** for future expansion to other platforms or languages
- **Production readiness** with full enterprise gRPC feature set from day one
- **Integrant integration** enabling clean lifecycle management and dependency injection
- **Ecosystem access** to the entire Java gRPC ecosystem
- **Performance optimisation** through mature Java implementations

### Negative

- **Learning curve** for developers not familiar with gRPC, Protocol Buffers, and Java interop
- **Slightly more complex setup** compared to REST APIs
- **Potential challenges in debugging** due to binary nature of communication
- **Interop complexity** requiring data conversion between Java objects and Clojure data structures
- **Additional dependencies** on Java gRPC libraries

### Mitigations

- Create Clojure wrapper functions for common gRPC operations
- Implement comprehensive logging at conversion boundaries  
- Develop testing patterns that work across the interop boundary
- Provide clear documentation and examples for the development team

## Implementation Approach

### Unified Clojure-Aware gRPC Architecture (Updated 2025)

**Breaking Change**: The implementation approach has been fundamentally revised to use a **unified Clojure-aware protobuf schema** that eliminates complex API introspection and reflection-based code generation. This approach enables **hot plugin installation** and dramatically simplifies the gRPC layer.

### 1. Unified Protobuf Schema

Replace domain-specific protobuf messages with a unified schema:

**Shared project** (`shared/src/main/proto/ooloi_universal.proto`):
```protobuf
syntax = "proto3";
package ooloi;

// Unified Clojure value representation
message OoloiValue {
  oneof value_type {
    string string_val = 1;
    int64 int_val = 2;
    double double_val = 3;
    bool bool_val = 4;
    ClojureRatio ratio_val = 5;
    ClojureKeyword keyword_val = 6;
    ClojureSymbol symbol_val = 7;
    ClojureMap map_val = 8;
    ClojureVector vector_val = 9;
    ClojureSet set_val = 10;
    ClojureList list_val = 11;
  }
}

message ClojureRatio {
  int64 numerator = 1;
  int64 denominator = 2;
}

message ClojureKeyword {
  optional string namespace = 1;
  string name = 2;
}

// Additional message types...
```

**VPD Compaction for Transmission:**

Vector Path Descriptors (VPDs) are automatically compacted before gRPC transmission for network efficiency:

```clojure
;; Before transmission: Compact form (what you write in code)
[:m 0 1 0 3 0]  ; 5 elements

;; After transmission: Navigator form (expanded internally if needed)
[:musicians 0 :instruments 1 :staves 0 :measures 3 :voices 0]  ; 11 elements
```

The gRPC layer ensures VPDs are always transmitted in compact form (`:m` or `:l` prefix notation), reducing network payload size by approximately 50-60% compared to navigator form. The conversion to navigator form happens only when needed for internal Specter operations, never during transmission.

**Performance Impact:**
- **Network bandwidth**: ~50-60% reduction in VPD payload size
- **Serialization overhead**: Negligible - compact form is the native representation
- **Memory efficiency**: Smaller messages reduce memory pressure on both client and server

```protobuf
// Continuing protobuf definition...

// Simplified gRPC service
message OoloiRequest {
  string method = 1;
  OoloiValue params = 2;
}

message OoloiResponse {
  bool success = 1;
  optional string error = 2;
  optional OoloiValue result = 3;
}

service OoloiService {
  rpc ExecuteMethod(OoloiRequest) returns (OoloiResponse);
  rpc ExecuteBatch(stream OoloiRequest) returns (OoloiResponse);
}
```

### 2. Dependencies and Build Configuration

**Shared project** (`shared/project.clj`):
```clojure
:dependencies [;; Java gRPC libraries:
               [io.grpc/grpc-netty "1.60.0"]
               [io.grpc/grpc-protobuf "1.60.0"] 
               [io.grpc/grpc-stub "1.60.0"]
               [com.google.protobuf/protobuf-java "3.25.1"]
               [integrant "0.13.0"]
               ;; existing dependencies...
               ]

:plugins [[lein-protoc "0.4.1"]
          ;; existing plugins...
          ]

:protoc {:proto-paths ["src/main/proto"]
         :output-path "target/generated-sources/grpc"
         :java-options {:language "java"}}

:java-source-paths ["target/generated-sources/grpc"]
```

### 3. Simplified Server Implementation

Replace complex reflection-based server with simple universal approach:

```clojure
(ns ooloi.backend.grpc.server
  (:require [ooloi.shared.grpc.clojure-conversion :as conv]
            [ooloi.shared.api :as api])
  (:import [io.grpc Status]
           [io.grpc.stub StreamObserver]))

(defn execute-method
  "Unified method executor for any API call."
  [request response-observer]
  (try
    (let [method-name (keyword (:method request))
          params (conv/proto->clj (:params request))
          
          ;; Dynamically resolve API function
          api-fn (ns-resolve 'ooloi.shared.api (symbol method-name))
          
          ;; Call the API function with converted parameters
          result (if (vector? params)
                   (apply api-fn params)
                   (api-fn params))
          
          ;; Build response
          response {:success true
                   :error ""
                   :result (conv/clj->proto result)}]
      
      (.onNext response-observer response)
      (.onCompleted response-observer))
    
    (catch Exception e
      (let [error-response {:success false
                           :error (.getMessage e)
                           :result nil}]
        (.onNext response-observer error-response)
        (.onCompleted response-observer)))))
```

### 4. Hot Plugin Installation Benefits

**Revolutionary Plugin Architecture**: The universal approach enables **zero-downtime plugin installation**:

- **No schema regeneration**: Plugins define new models → universal OoloiValue handles them automatically
- **No server restart**: New API methods discovered dynamically at runtime
- **Perfect type fidelity**: Plugin data (ratios, keywords, custom types) preserved exactly
- **Infinite extensibility**: Any plugin data structure automatically supported

**Plugin Installation Process**:
```bash
# Plugin installs → System continues running seamlessly
1. Plugin installs: New defrecords, API methods, streaming handlers
2. Unified OoloiValue handles all new data types immediately  
3. Dynamic function resolution finds new API methods
4. Perfect type fidelity preserves plugin semantics
# Result: Zero downtime, hot installation
```

This transforms Ooloi from a **static system requiring restarts** to a **live, hot-pluggable platform** suitable for a thriving plugin ecosystem.

#### Shared Directory Dual Purpose Architecture

The **shared project serves two distinct but complementary purposes**:

**Purpose 1: Shared Code Repository**
- **Protocol Buffer definitions** (`shared/src/main/proto/`) - Both frontend and backend generate identical Java classes
- **VPD utilities** (`shared/src/main/clojure/ooloi/shared/vpd_utils.clj`) - Both sides manipulate Vector Path Descriptors  
- **Protocol conversion** (`shared/src/main/clojure/ooloi/shared/proto_conversion.clj`) - Bidirectional Clojure ↔ Protocol Buffer conversion
- **Musical constants** (`shared/src/main/clojure/ooloi/shared/constants.clj`) - Shared enums, key signatures, note names
- **Build utilities** (`shared/src/main/clojure/ooloi/shared/build.clj`) - Cross-project packaging tools

**Purpose 2: Combined Application Builder**  
- **Dependency orchestration** - Pulls in both backend and frontend components as dependencies
- **Single executable creation** - Packages standalone applications with embedded server and client
- **Platform packaging** - Generates platform-specific installers (DMG/MSI/DEB) containing both components
- **Runtime coordination** - Manages startup/shutdown of both services in the same JVM process

**Build Dependency Flow**:
```
Phase 1: shared/ builds independently (contains proto source + utilities)
Phase 2: backend/ + frontend/ build in parallel (depend on shared/, generate Java classes)  
Phase 3: shared/ builds combined application (depends on backend/ + frontend/)
```

This dual-purpose architecture enables Ooloi's unique **three deployment modes** (backend-only, frontend-only, combined) while maximizing code reuse and maintaining type safety.

**Code Generation Feedback Loop:**
The build process creates a continuous feedback cycle:
1. Generate `.proto` files from `api.clj` namespace introspection → `shared/src/main/proto/`
2. `lein-protoc` generates Java classes from Protocol Buffer definitions in all projects
3. gRPC server implementations delegate directly to existing `api.clj` functions
4. Frontend clients call generated stubs for 1:1 API correspondence

### 2. Define Protocol Buffer Messages and Services

Create comprehensive `.proto` files in `shared/src/main/proto/` for all shared data structures (e.g., musical elements, layout information) and service definitions. These will be used to generate classes for backend server implementation, frontend client usage, and combined deployments.

### 3. Code Generation Pipeline

Set up automated code generation for both frontend and backend using `lein-protoc` plugin, ensuring generated classes are included in the project classpath.

### 4. Backend gRPC Server Implementation

Implement gRPC server services in the backend using Integrant methods with proper dependency injection:

```clojure
(ns ooloi.backend.grpc.service
  (:require [integrant.core :as ig]
            [ooloi.shared.api :as api])
  (:import [io.grpc Server ServerBuilder]
           [io.grpc.stub StreamObserver]
           [ooloi.backend OoloiGrpc$OoloiImplBase]
           [ooloi.backend CreatePieceRequest Piece GetPieceRequest]))
```

The frontend will implement corresponding gRPC client code to make calls to these backend services.

### 5. Architectural Separation

- **Shared Project (`shared/`)**: Serves dual purposes - contains `.proto` files and shared utilities for code reuse, plus builds combined binaries with both client and server
- **Backend Component**: Implements gRPC server that delegates to existing `api.clj` functions, managed by Integrant
- **Frontend Component**: Makes client calls to backend server using generated classes  
- **API Layer (`api.clj`)**: Defines complete public interface - every function becomes a gRPC method
- **Thin gRPC Layer**: Handles only data conversion and transport, delegates all operations to `api.clj`
- **Data Conversion**: Efficient bidirectional conversion utilities between Protocol Buffers and Clojure data structures
- **Deployment Flexibility**: Same codebase supports combined deployment (single process) or distributed deployment (separate processes)

### 6. Backend Client Registration and Streaming Implementation

Implement client registration with integrated event streaming in the backend server for real-time invalidation notifications using gRPC's streaming capabilities with proper resource management and error handling. Client registration establishes the primary connection, with event streaming as an integrated capability. The frontend client registration process requires **explicit connection establishment** after component initialization, giving applications control over when network resources are allocated and connections are established.

**Client Validation Integration**: Registration includes comprehensive client-id validation with format enforcement (`^[a-zA-Z0-9_-]{3,64}$`), uniqueness checking, and proper error responses (`ALREADY_EXISTS` for duplicates, `INVALID_ARGUMENT` for format violations). Failed validations increment error statistics and properly clean up allocated resources.

### 7. Error Handling and Retry Mechanisms

Implement robust error handling using gRPC status codes with comprehensive retry mechanisms for resilient communication.

### 8. Testing Infrastructure

Develop comprehensive testing suites covering:
- Unit tests for backend service methods
- Integration tests for full client-server interactions between frontend and backend
- Performance tests for large score handling across the network
- Mock services for controlled testing environments
- Frontend client connection and error handling tests

### 9. Security Implementation

Implement TLS encryption and authentication mechanisms for all deployments, following a **security-first architecture**:

#### TLS Everywhere Policy

**Default Configuration:**
- **Default port**: 10700 ("OOLOI" backwards in leet-speak) for all environments
- **Production alternatives**: Port 443 for maximum firewall compatibility
- **Development**: TLS enabled by default
- **Production**: TLS required
- **Debugging**: Optional TLS disable via environment variable

**Port Strategy:**
- **Port 10700**: Default choice for all deployments
  - No root privileges required
  - Unique to Ooloi ("OOLOI" backwards in leet-speak)
  - Avoids conflicts with standard services
  - Consistent across development and production
- **Port 443**: Alternative for production environments requiring maximum compatibility
  - Firewall-friendly in corporate environments
  - No port specification needed for clients
  - Punch-through capability for NAT/proxy scenarios
- **Port 8443**: Alternative for "alternate HTTPS" without root privileges

**Certificate Management:**
- **Development**: Auto-generated self-signed certificates on first run
- **Production**: Standard CA-signed certificates or integration with external cert providers
- **Team Environment**: Shared development CA for consistent experience

**Development Tooling:**
```bash
# Standard development server (TLS enabled)
OOLOI_TLS=true OOLOI_PORT=10700 ./ooloi-backend
./ooloi-backend --tls=true

# Debugging server (TLS disabled)
OOLOI_TLS=false OOLOI_PORT=10700 ./ooloi-backend  
./ooloi-backend --tls=false

# Production server (TLS required)
OOLOI_TLS=true OOLOI_PORT=443 ./ooloi-backend
./ooloi-backend --port=443 --tls=true
```

**Build Tools:**
- `make dev-certs` - generates local development certificates

#### Security Benefits

1. **Development Parity**: TLS in development catches encryption-related issues early
2. **Security Habits**: Developers never accidentally transmit sensitive musical data in plaintext
3. **Production Readiness**: No "we'll add TLS later" technical debt
4. **Corporate Compatibility**: Port 443 ensures functionality in locked-down environments
5. **Team Scalability**: New developers get secure-by-default setup automatically

### 10. System Startup and Communication Flow

**Deployment Model 1: Combined Binary**
1. Single application starts with both backend and frontend components
2. Backend component starts gRPC server (typically localhost)
3. Frontend component initializes gRPC client components (no network connection yet)
4. Application logic calls `register-with-server` when ready to establish connections (e.g., after UI initialization)
5. All communication happens in-process or via localhost with integrated streaming

**Deployment Model 2: Separate Backend/Frontend**
1. Backend binary starts independently with gRPC server on configured port
2. Frontend binary starts independently as JavaFX application
3. Frontend gRPC client components initialize (no network connection yet)
4. Application logic calls `register-with-server` when ready to connect to backend server over network
5. Connection establishment creates both API capability and event streaming for all musical operations

**Deployment Model 3: Backend-only**
1. Backend binary starts with gRPC server
2. External clients (potentially future web frontend, mobile apps, etc.) initialize client components
3. Client applications call connection establishment methods when ready to connect
4. Useful for headless servers or API-only deployments

### 11. Monitoring and Observability

Set up gRPC-specific metrics collection and distributed tracing for production monitoring.

## Alternatives Considered

1. **Protojure (Native Clojure)**: Rejected due to production limitations including missing enterprise features like automatic client reconnection, manual trailer handling requirements, and performance constraints in high-load scenarios.

2. **REST API with JSON**: Rejected due to performance concerns with large datasets, lack of native streaming support, and absence of strong typing for complex musical data structures.

3. **WebSocket**: Considered for its real-time capabilities but rejected due to lack of built-in type safety, less structured approach to API definition, and absence of sophisticated error handling mechanisms.

4. **Apache Thrift**: Similar benefits to gRPC but rejected due to gRPC's better language support, more active community, and superior streaming capabilities.

5. **Custom Binary Protocol**: Considered for maximum performance but rejected due to development overhead, lack of tooling, and reinvention of solved problems.

### Port Number Alternatives Considered

1. **Port 50051**: Standard gRPC convention, but generic and unmemorable for team
2. **Port 8080**: Common development port, but potential conflicts with other services
3. **Port 8443**: Good alternative HTTPS port, but lacks team significance
4. **Port 443**: Excellent for production compatibility, but requires root privileges in development
5. **Port 10700**: Chosen as default - memorable ("OOLOI" backwards in leet-speak), no conflicts, no root required

### TLS Implementation Alternatives Considered

1. **Production-only TLS**: Rejected due to development/production parity concerns and potential security issues
2. **Optional TLS everywhere**: Rejected due to complexity and potential for insecure defaults
3. **TLS with manual certificate management**: Rejected due to developer friction and setup complexity
4. **TLS with auto-generated certificates**: Chosen for balance of security and developer experience

## References

### Related ADRs
- [ADR-0000: Clojure](0000-Clojure.md) - Language foundation enabling Java interop required for gRPC
- [ADR-0001: Frontend-Backend Separation](0001-Frontend-Backend-Separation.md) - Architectural decision requiring communication protocol
- [ADR-0015: Undo and Redo](0015-Undo-and-Redo.md) - Undo/redo coordination using gRPC streaming
- [ADR-0018: API-gRPC Interface and Events](0018-API-gRPC-Interface-and-Events.md) - Unified API generation and event broadcasting leveraging gRPC capabilities
- [ADR-0019: In-Process gRPC Transport Optimization](0019-In-Process-gRPC-Transport-Optimization.md) - Performance optimization for gRPC transport
- [ADR-0024: gRPC Concurrency and Flow Control Architecture](0024-gRPC-Concurrency-and-Flow-Control-Architecture.md) - Concurrency model and flow control architecture analysis
- [ADR-0025: Server Statistics Architecture](0025-Server-Statistics-Architecture.md) - Comprehensive production monitoring and health endpoints for gRPC services

### Technical Documentation
- [Integrant Documentation](https://github.com/weavejester/integrant)  
- [grpc-java Documentation](https://grpc.io/docs/languages/java/)
- [Protocol Buffers Documentation](https://developers.google.com/protocol-buffers)

## Notes

While this approach requires additional interop handling compared to native Clojure solutions, the trade-off strongly favours production reliability and feature completeness. The Integrant-based architecture ensures that gRPC concerns remain properly isolated from business logic, maintaining clean separation of transport and domain concerns.

The implementation should monitor performance and developer experience in practice. Should unexpected complexities or performance issues arise, this decision may need reevaluation, though the current evidence strongly supports the Java interop approach for production systems.

We should also monitor the evolution of gRPC and related technologies, particularly any improvements to native Clojure implementations, to ensure we continue using the most effective communication method as the project scales.
