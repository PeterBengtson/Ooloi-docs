# ADR: Implementation of Vector Path Descriptors (VPDs)

## Status

Accepted

## Context

Ooloi deals with complex, hierarchical musical structures that need to be efficiently referenced, manipulated, and communicated between different parts of the system. We need a way to uniquely identify and address specific elements within a musical score, from high-level structures like instruments and staves down to individual notes and articulations. This addressing system needs to be compact, efficient, and flexible enough to handle both the musical and visual hierarchies of a score.

## Decision

We will implement Vector Path Descriptors (VPDs) as the primary method for addressing and referencing elements within Ooloi's musical structures. VPDs use a compact notation that can be converted to navigator form for use with Specter and standard Clojure path navigation functions.

### Core Terminology

- **VPD (Vector Path Descriptor)**: The compact form used as the default throughout Ooloi. Examples: `[:m 0 1 2]`, `[:l 0 1]`
- **Navigator**: The expanded form compatible with Specter operations and standard Clojure path functions. Examples: `[:musicians 0 :instruments 1 :staves 2]`, `[:layouts 0 :page-views 1]`
- **Conversion**: The `vpd/navigator` function converts VPDs to navigator form. This is idempotent - calling it on a navigator returns the navigator unchanged.
- **Path Extension**: Navigators can be extended with attribute names to create Specter paths: `(conj [:musicians 0] :name)` → `[:musicians 0 :name]`

## Rationale

1. Consistency: VPDs provide a uniform way to reference elements across different parts of the codebase.
2. Efficiency: They allow for compact representation of paths, which is especially useful in communication between frontend and backend.
3. Flexibility: VPDs can easily accommodate both musical and visual hierarchies.
4. Scalability: As the project grows, VPDs make it easier to add new operations without changing the fundamental way of addressing elements.
5. Transaction support: VPDs work seamlessly with Ooloi's transaction system, ensuring operations are performed within the context of the current piece transaction.
6. Integration with existing tools: VPDs can be easily used with libraries like Specter for powerful data structure traversal and manipulation.

## VPD Structure and Examples

VPDs are vectors that describe a path to a specific element within the nested structure of a Ooloi piece. They come in two forms:

### VPD Form (Compact - Default)

The compact form is the default and uses prefix keywords followed by indices:

```clojure
[:m index1 index2 ... indexN]  ; Musical hierarchy
[:l index1 index2 ... indexN]  ; Layout hierarchy
```

The prefix keywords map to hierarchical structures:
- `:m` → `[:musicians :instruments :staves :measures :voices]`
- `:l` → `[:layouts :page-views :system-views :staff-views :measure-views]`

### Navigator Form (Expanded)

The navigator form alternates between keywords and indices, compatible with Specter and standard Clojure path operations:

```clojure
[:keyword1 index1 :keyword2 index2 ... :keywordN indexN]
```

This form is generated by the `vpd/navigator` function and is used internally for navigation operations.

### Examples

1. **VPD form (compact - the default)**:
   ```clojure
   [:m 0 1 0 3 0]  ; Voice 0 of measure 3 in staff 0 of instrument 1 of musician 0
   [:l 0 2 1 0 3]  ; Measure-view 3 of staff-view 0 in system-view 1 of page-view 2 in layout 0
   ```

2. **Navigator form (expanded for Specter)**:
   ```clojure
   [:musicians 0 :instruments 1 :staves 0 :measures 3 :voices 0]
   [:layouts 0 :page-views 2 :system-views 1 :staff-views 0 :measure-views 3]
   ```

3. **Conversion between forms**:
   ```clojure
   (vpd/navigator [:m 0 1 0 3 0])
   ; => [:musicians 0 :instruments 1 :staves 0 :measures 3 :voices 0]

   (vpd/compact [:musicians 0 :instruments 1 :staves 0 :measures 3 :voices 0])
   ; => [:m 0 1 0 3 0]
   ```

4. **Extending navigators with attributes** (the `conj` pattern):
   ```clojure
   (conj [:m 0 1] :name)  ; => [:musicians 0 :instruments 1 :name]
   (conj [:m 0] :staves)  ; => [:musicians 0 :instruments 0 :staves]
   ```
   This pattern is used internally to build Specter paths for attribute access.

5. **Accessing items within a measure**:
   ```clojure
   [:m 0 1 0 3 0 :items 2]  ; The 3rd item in the specified voice
   ```

6. **Nested structures (e.g., tuplets)**:
   ```clojure
   [:m 0 1 0 3 0 :items 5 :items 1]  ; The 2nd item in item 5 (if it's a tuplet) of the specified voice
   ```

## Usage Examples

All API calls use VPDs in their compact form. Conversion to navigator form happens internally:

1. **Adding an articulation**:
   ```clojure
   (add-articulation [:m 0 1 0 3 0] piece-id :staccato)
   ```
   Adds a staccato articulation to the specified voice.

2. **Getting a specific item**:
   ```clojure
   (get-item [:m 0 1 0 3 0 :items 2] piece)
   ```
   Retrieves the third item in the specified voice.

3. **Updating a layout element**:
   ```clojure
   (set-staff-spacing [:l 0 2 1] piece-id 20)
   ```
   Sets the staff spacing for system-view 1 of page-view 2 in layout 0 to 20.

4. **Setting a property of a specific element**:
   ```clojure
   (set-duration [:m 0 1 0 3 0 :items 2] piece [1/4 2])
   (set-name [:m 0 1] piece "Violin I")
   ```
   Sets properties using VPD addressing.

## Internal Implementation

### VPD to Navigator Conversion

The `vpd/navigator` function converts compact VPDs to navigator form:

```clojure
(defn navigator [vpd]
  ;; Converts [:m 0 1 0 3 0] to [:musicians 0 :instruments 1 :staves 0 :measures 3 :voices 0]
  ;; Already in navigator form? Returns unchanged (idempotent)
  ...)
```

### Path Extension Pattern

Internal operations extend navigators with attributes using `conj`:

```clojure
;; From access.clj
(defn vpd-set-attribute [vpd piece attr-name value]
  (vpd/mutate (conj vpd attr-name) piece value))

;; Example: Setting the name of musician 0
(vpd-set-attribute [:m 0] piece :name "Violin I")
;; Internally: (vpd/mutate [:musicians 0 :name] piece "Violin I")
```

### Type Discrimination

The system distinguishes between VPDs and regular Specter paths:

```clojure
(defn- vpd? [v]
  "Returns true if v is a VPD (starts with :musicians, :layouts, :m, :l, or is [])"
  (or (empty? v)
      (#{:musicians :layouts :m :l} (first v))))
```

This allows `vpd/mutate` and `vpd/retrieve` to handle both:
- **VPDs**: Convert to navigator form, then use Specter
- **Regular paths**: Pass directly to Specter (for extended paths like `[:musicians 0 :name]`)

## Consequences

### Positive

- Unified addressing scheme across the entire application.
- Simplified API for accessing and modifying score elements.
- Efficient communication of element references between frontend and backend.
- Easier implementation of operations like copy/paste, drag-and-drop, and undo/redo.
- Seamless integration with Ooloi's transaction system.

### Negative

- Learning curve for developers to understand and use VPDs effectively.
- Potential for invalid paths if not properly validated.
- May require custom serialization/deserialization for persistence and network communication.

## Implementation Approach

1. Define a clear syntax for VPDs, with compact form (`:m`, `:l`) as the default and navigator form for Specter operations.
2. Implement core functions for creating, validating, and converting VPDs:
   - `vpd/navigator`: Convert compact VPD to navigator form (idempotent)
   - `vpd/compact`: Convert navigator form to compact VPD (idempotent)
   - `vpd/retrieve`: Navigate to element using VPD (handles both forms)
   - `vpd/mutate`: Update element using VPD (handles both forms)
3. Integrate VPDs with Specter through the navigator form, enabling efficient traversal and manipulation.
4. Implement type discrimination (`vpd?` predicate) to distinguish VPDs from extended Specter paths.
5. Support path extension pattern `(conj vpd attr-name)` for building Specter paths from VPDs.
6. Implement serialization and deserialization methods for VPDs in gRPC communication (compact form is transmitted).
7. Create utility functions for common VPD operations (e.g., hierarchy accessors: `musician`, `instrument`, `staff`, `measure`, `voice`).
8. Develop comprehensive testing suites for VPD creation, conversion, resolution, and manipulation.
9. Update API functions to use the pattern of `(function-name vpd piece-or-id ...other-args)`.
10. Update documentation to clarify the distinction between VPD form (compact, default) and navigator form (for Specter).

## Alternatives Considered

1. String-based Paths: Rejected due to less efficient parsing and higher verbosity.
2. Integer-based Indexing: Rejected due to lack of clarity and difficulty in representing complex hierarchies.
3. Object References: Rejected due to issues with serialization and communication between frontend and backend.

## Reference Implementation

The VPD system is implemented in [`ooloi.shared.ops.vpd`](/shared/src/main/clojure/ooloi/shared/ops/vpd.clj), which provides functions for converting, canonicalizing, and using VPDs.

## Related Decisions

- [ADR-0010: Pure Trees](0010-Pure-Trees.md) - VPDs are designed to work efficiently with the pure tree structure
- [ADR-0014: Timewalk](0014-Timewalk.md) - Timewalk operations use VPDs extensively for boundary specification and results  
- [ADR-0002: gRPC](0002-gRPC.md) - VPDs are used in gRPC communication to identify change locations
